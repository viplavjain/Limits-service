import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EPCDeviceServiceTest {

    @InjectMocks
    private EPCDeviceService epcDeviceService;

    @Mock
    private TokenService tokenService;

    @Mock
    private GenericWebClient genericWebClient;

    @Mock
    private EPCConfiguration epcConfiguration;

    private final String sorId = "testSorId";
    private final String env = "testEnv";
    private final String bearerToken = "Bearer testToken";

    @BeforeEach
    void setUp() {
        when(tokenService.getToken(anyString())).thenReturn(Mono.just(new Token("testToken")));
    }

    @Test
    void testGetEPCDeviceDetails_Success() {
        ProductOfferSearchRequest request = new ProductOfferSearchRequest();
        DeviceEpcDto expectedDto = new DeviceEpcDto();

        when(genericWebClient.callPostApi(any(), any(), any(), eq(AmdocsSearchResponse.class), any()))
                .thenReturn(Mono.just(new AmdocsSearchResponse()));

        Mono<DeviceEpcDto> result = epcDeviceService.getEPCDeviceDetails(sorId, env);

        StepVerifier.create(result)
                .expectNext(expectedDto)
                .verifyComplete();
    }

    @Test
    void testGetEPCDeviceDetails_TokenServiceFailure() {
        when(tokenService.getToken(anyString())).thenReturn(Mono.error(new RuntimeException("Token error")));

        Mono<DeviceEpcDto> result = epcDeviceService.getEPCDeviceDetails(sorId, env);

        StepVerifier.create(result)
                .expectErrorMatches(throwable -> throwable instanceof CustomEPCException && throwable.getMessage().contains("Unexpected error in generating token"))
                .verify();
    }

    @Test
    void testCreateSearchRequest_ExceptionHandling() {
        assertThrows(CustomEPCException.class, () -> epcDeviceService.createSearchRequest(null));
    }

    @Test
    void testFetchProductOffering_ExceptionHandling() {
        when(genericWebClient.callPostApi(any(), any(), any(), eq(AmdocsSearchResponse.class), any()))
                .thenReturn(Mono.error(new RuntimeException("API Failure")));

        Mono<DeviceEpcDto> result = epcDeviceService.fetchProductOffering(bearerToken, env, new ProductOfferSearchRequest());

        StepVerifier.create(result)
                .expectNext(new DeviceEpcDto())
                .verifyComplete();
    }

    @Test
    void testFetchProductSpecification_ExceptionHandling() {
        when(genericWebClient.callPostApi(any(), any(), any(), eq(ProductOfferingResponse.class), any()))
                .thenReturn(Mono.error(new RuntimeException("Product Spec API Failure")));

        Mono<DeviceEpcDto> result = epcDeviceService.fetchProductSpecification(bearerToken, env, "documentID");

        StepVerifier.create(result)
                .expectNext(new DeviceEpcDto())
                .verifyComplete();
    }

    @Test
    void testFetchProductDetails_ExceptionHandling() {
        Mono<ProductOfferingPriceResponse> priceResponse = Mono.just(new ProductOfferingPriceResponse());
        when(genericWebClient.callPostApi(any(), any(), any(), eq(ProductOfferingResponse.class), any()))
                .thenReturn(Mono.error(new RuntimeException("Product Details API Failure")));

        Mono<DeviceEpcDto> result = epcDeviceService.fetchProductDetails(bearerToken, env, new ProductOfferingResponse(), priceResponse, "specId");

        StepVerifier.create(result)
                .expectNext(new DeviceEpcDto())
                .verifyComplete();
    }
}
